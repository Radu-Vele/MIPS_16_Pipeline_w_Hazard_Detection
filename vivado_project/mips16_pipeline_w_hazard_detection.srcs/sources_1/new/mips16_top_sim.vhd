----------------------------------------------------------------------------------
-- Company: TUCN
-- Engineer: Radu-Augustin Vele
-- 
-- Create Date: 11/25/2022 07:25:33 PM
-- Design Name: 
-- Module Name: mips16_top_sim - Behavioral
-- Project Name: MIPS 16 Pipeline with Hazard Detection and Avoidance
-- Target Devices: Basys3
-- Tool Versions: 
-- Description: Top level module for simulation purposes
-- 
-- Dependencies: -
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.std_logic_unsigned.ALL;
use IEEE.numeric_std.ALL;

entity mips16_top_sim is
    Port ( 
        clk: in std_logic;
        reset: in std_logic;
        --signals used when tested on the board
        en_pc: in std_logic;
        en_mem_wr: in std_logic; 
        en_rf_wr: in std_logic
    );
end mips16_top_sim;

architecture Behavioral of mips16_top_sim is
-- Components declaration

    component IF_unit is
        Port (
            clk100MHz: in std_logic;
            jump_addr: in std_logic_vector(15 downto 0);
            branch_addr: in std_logic_vector(15 downto 0);
            jump_ctrl: in std_logic;
            PCsrc_ctrl: in std_logic;
            reset_pc: in std_logic;
            enable_pc: in std_logic; 
            instruction: out std_logic_vector(15 downto 0);
            pc_plus_one: out std_logic_vector(15 downto 0));
    end component;
    
    component ID_unit is
        Port ( 
            clk100MHz: in std_logic;
            instruction: in std_logic_vector(15 downto 0);
            wd: in std_logic_vector(15 downto 0);
            RegWrite: in std_logic;
            RegDstAddress: in std_logic_vector(2 downto 0);
            ExtOp: in std_logic;
            rd1: out std_logic_vector(15 downto 0);
            rd2: out std_logic_vector(15 downto 0);
            ext_imm: out std_logic_vector(15 downto 0);
            func: out std_logic_vector(2 downto 0);
            sa: out std_logic;
            write_address_1: out std_logic_vector(2 downto 0);
            write_address_2: out std_logic_vector(2 downto 0)
        );
    end component;
    
    component ctrl_unit is
      Port ( 
        opcode: in std_logic_vector (2 downto 0);
        RegDst: out std_logic;
        ExtOp: out std_logic;
        ALUSrc: out std_logic;
        Branch: out std_logic;
        Jump: out std_logic;
        ALUOp: out std_logic_vector(1 downto 0);
        MemWrite: out std_logic;
        MemtoReg: out std_logic;
        RegWrite: out std_logic);
    end component;
    
    component EX_unit is
        Port ( 
            next_pc: in std_logic_vector(15 downto 0);
            rd1: in std_logic_vector(15 downto 0); 
            rd2: in std_logic_vector(15 downto 0);
            ALUSrc: in std_logic;
            ext_imm: in std_logic_vector(15 downto 0);
            sa: in std_logic;
            func: in std_logic_vector(2 downto 0);
            ALUOp: in std_logic_vector(1 downto 0);
            branch_address: out std_logic_vector(15 downto 0);
            zero: out std_logic;
            ALURes: out std_logic_vector (15 downto 0)
        );
    end component;
    
    component mem_unit is
        Port ( 
            clk100MHz: in std_logic;
            MemWrite: in std_logic;
            ALURes: in std_logic_vector (15 downto 0);
            RD2: in std_logic_vector (15 downto 0);
            ALURes_out: out std_logic_vector (15 downto 0);
            MemData: out std_logic_vector (15 downto 0)
        );
    end component;
    
--Signals
    
    --generated by control unit
    signal C_RegWrite: std_logic;
    signal C_RegWriteValid: std_logic; -- validated with an MPG output
    signal C_RegDst: std_logic;
    signal C_ExtOp: std_logic;
    signal C_ALUSrc: std_logic;
    signal C_Branch: std_logic;
    signal C_Jump: std_logic;
    signal C_MemWrite: std_logic;
    signal C_MemWriteEnable: std_logic;
    signal C_MemToReg: std_logic;
    signal C_ALUOp: std_logic_vector(1 downto 0);
    signal C_PCSrc_ctrl: std_logic;
    
    --outputs of IF
    signal IF_instruction: std_logic_vector(15 downto 0);
    signal IF_pc_plus_one: std_logic_vector(15 downto 0);
    
    --outputs of ID
    signal ID_rd1: std_logic_vector(15 downto 0); 
    signal ID_rd2: std_logic_vector(15 downto 0);
    signal ID_ext_imm: std_logic_vector(15 downto 0);
    signal ID_sa: std_logic;
    signal ID_func: std_logic_vector(2 downto 0); 
    signal ID_wr_addr1: std_logic_vector(15 downto 0);
    signal ID_wr_addr2: std_logic_vector(15 downto 0);
    
    --outputs of EX
    signal EX_branch_addr: std_logic_vector(15 downto 0);
    signal EX_zero: std_logic; 
    signal EX_ALU_out: std_logic_vector(15 downto 0);
    
    --outputs of MEM
    signal MEM_ALU_out: std_logic_vector(15 downto 0);
    signal MEM_data_out: std_logic_vector(15 downto 0);
    
    
    --outputs of WB
    signal WB_w_data: std_logic_vector(15 downto 0);
    
    -- misc
    signal EX_wr_addr: std_logic_vector(2 downto 0);

-- Pipeline registers
    signal IF_ID: std_logic_vector(32 downto 0);
    
    -- MSB                  LSB
    --  ----------------------
    -- | Instruction | PC + 1 | 
    --  ----------------------
    -- 31           15       0
    
    signal ID_EX: std_logic_vector(82 downto 0);
    
    -- MSB                                                                                         LSB
    --  ----------------------------------------------------------------------------------------------
    -- | WB CTRL | MEM CTRL | EX CTRL | PC + 1 | RD1 | RD2 | EXT_IMM | Wr_Add1 | Wr_addr2 | sa | func |
    --  ----------------------------------------------------------------------------------------------
    -- 81        79         77        73       57    41    25        9         6          3    2      0    
    
    signal EX_MEM: std_logic_vector(56 downto 0);
    
    -- MSB                                                                       LSB
    --  -----------------------------------------------------------------------------
    -- | WB CTRL | MEM CTRL | Branch_addr | Zero | ALU_out |   RD2   | Wr_Add_chosen |    
    --  -----------------------------------------------------------------------------
    -- 55        53         51           35     34         18        2               0            
    
    signal MEM_WB: std_logic_vector(33 downto 0);
    
    -- MSB                                              LSB
    --  ---------------------------------------------------
    -- | WB CTRL | Wr_Add_chosen | MEM Data Out |  ALU Out | 
    --  ---------------------------------------------------
    -- 36        34             31             15         0
       
begin

    IF_connect: IF_unit port map (
        clk100MHz => clk,
        jump_addr => ID_ext_imm,
        branch_addr => EX_MEM(51 downto 36),
        jump_ctrl => C_Jump,
        PCsrc_ctrl => C_PCSrc_ctrl, -- TRICKY
        reset_pc => reset,
        enable_pc => en_pc, 
        instruction => IF_instruction,
        pc_plus_one  => IF_pc_plus_one
    );
    
    pl_IF_ID: process(clk) is 
    begin
        if rising_edge(clk) then
            IF_ID(31 downto 16) <= IF_instruction;
            IF_ID(16 downto 0) <= IF_pc_plus_one;
        end if;
    end process;    
    
    ID_connect: ID_unit port map (
        clk100MHz => clk,
        instruction => IF_ID(31 downto 16),
        wd => WB_w_data,
        RegWrite => C_RegWrite,
        RegDstAddress => MEM_WB(34 downto 32), 
        ExtOp => C_ExtOp,
        rd1 => ID_rd1,
        rd2 => ID_rd2,
        ext_imm => ID_ext_imm,
        func => ID_func,
        sa => ID_sa,
        write_address_1 => ID_wr_addr1,
        write_address_2 => ID_wr_addr2
    );
    
    pl_ID_EX: process(clk) is
    begin
        if (rising_edge(clk)) then
            ID_EX(81) <= C_MemToReg;
            ID_EX(80) <= C_RegWrite;
            ID_EX(79) <= C_MemWrite;
            ID_EX(78) <= C_Branch;
            ID_EX(77 downto 76) <= C_ALUOp;
            ID_EX(75) <= C_ALUSrc;
            ID_EX(74) <= C_RegDst;
            ID_EX(73 downto 58) <= IF_ID(15 downto 0);
            ID_EX(57 downto 42) <= ID_rd1;
            ID_EX(41 downto 26) <= ID_rd2;
            ID_EX(25 downto 10) <= ID_ext_imm;
            ID_EX(9 downto 7) <= ID_wr_addr1;
            ID_EX(6 downto 4) <= ID_wr_addr2;
            ID_EX(3) <= ID_sa;
            ID_EX(2 downto 0) <= ID_func;
        end if;
    end process;
    
    EX_connect: EX_unit port map (
        next_pc => ID_EX(73 downto 58),
        rd1 => ID_EX(57 downto 42),
        rd2 => ID_EX(41 downto 26),
        ALUSrc => ID_EX(75),
        ext_imm => ID_EX(25 downto 10),
        sa => ID_EX(3),
        func => ID_EX(2 downto 0),
        ALUOp => ID_EX(77 downto 76),
        branch_address => EX_branch_addr,
        zero => EX_zero,
        ALURes => EX_ALU_out
    );
    
    mux_wr_addr_choice: EX_wr_addr <= 
        ID_EX(9 downto 5) when ID_EX(74) = '0' 
        else ID_EX(6 downto 4); -- TRICKY

    
    pl_EX_MEM: process(clk) is
    begin
        if rising_edge(clk) then 
            EX_MEM(55 downto 54) <= ID_EX(81 downto 80);
            EX_MEM(53 downto 52) <= ID_EX(79 downto 78);
            EX_MEM(51 downto 36) <= EX_branch_addr;
            EX_MEM(35) <= EX_zero;
            EX_MEM(34 downto 19) <= EX_ALU_out;
            EX_MEM(18 downto 3) <= ID_EX(41 downto 26);
            EX_MEM(2 downto 0) <= EX_wr_addr;
        end if;    
    end process;
    
    MEM_connect: MEM_unit port map(
        clk100MHz => clk,
        MemWrite => EX_MEM(53),
        ALURes => EX_MEM(34 downto 29), 
        RD2 => EX_MEM(18 downto 3),
        ALURes_out => MEM_ALU_out,
        MemData => MEM_data_out
    );
    
    pl_MEM_WB: process(clk) is
    begin
        if rising_edge(clk) then 
            MEM_WB(36 downto 35) <= EX_MEM(55 downto 54);
            MEM_WB(34 downto 32) <= EX_MEM(2 downto 0);
            MEM_WB(31 downto 16) <= MEM_data_out;
            MEM_WB(15 downto 0) <= MEM_ALU_out;
        end if;
    end process;
    
    WB_unit: WB_w_data <= 
        MEM_WB(31 downto 16) when MEM_WB(36) = '1'
        else MEM_WB(15 downto 0);
    

end Behavioral;
 